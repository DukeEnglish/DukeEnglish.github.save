---
layout: post
title:  "快速排序"
date:   2017-09-22 
catagories: Algorithm
tags: Algorithm
---

天了咯，最近找工作真的挺辛苦的。虽然我本科确实很渣，但是确实面试要考很多很基础的东西啊。怎么办呢？复习咯！
今天我想说一个非常流行的排序算法，叫做快速排序。

顾名思义，他就是一个很快的排序算法。

嗯我们先进入正题，至于他为什么快，我们接下来再分析：

给定一串数字（9个 1 - 9）

2 6 1 8 3 4 9 7 5

我们的任务是将之从小到大进行排列，怎么做？
这里有一个方法，叫做快速排序的方法。其基本思想是将从一行数列中随机找一个数字，然后找到这个数字的位置使其最左边都是比他小的数字，最右边都是比他大的数字。

虽然都说随便找，但是一般大家都找最左边的耶。所以我们就以最左边的数字作为基准数字，然后我们来找一个最左边的2应该在哪里呢？我们知道答案应该是在从左边数第二个位置处。可是计算机不知道啊，所以我们要一步一步教电脑怎么做。

第一步，是找好基准数字：2
第二步，是从右往左找一个比2小或者等于的数字，我们找到1(必须先从右边开始，因为基准数字在左边，如果先从左边开始找一个比基准数字大的数字的话，若是第三步无法找到一个比基准数小的数字，那么按照我们的算法依然进行基准数字和找到的数字交换的话，就会造成2左边有一个比2大的数字)
第三步，是从左边找一个比2大的数字，并且不能够越过那个刚刚找到的比2小的数字的位置，发现6
第四步，将1和6交换位置 变成 2 1 6 8 3 4 9 7 5
第五步，如果从左边的寻找没有走到第二步中找到的那个数字所在的位置，重复第二步到第四步；否则直接跳到第六步
第六步，将基准数字和第三步中找到的数字所在的位置交换。这样就变成了126834975
所以我们看到，2左边都小于2；2右边都大于2
第七步，对2左边的序列和2右边的序列递归实现

PS，因为1只有一个，所以直接保持原样。
所以一共会有这么几次排序变化：
ORIGINAL:261834975
1:126834975
2:124536978（其中有一步会发现左右两边的扫描在6所在的位置重合（4），这个时候直接将这个数字4和6交换就可以得到想要的结果）
3：123456879
4：123456789

代码（C++）:

`#include<stdio.h>
int a[1000],n;
void quicksort(int left, int right){
    if (left >=right){
        return;
    }
    int temp =a[left];
    int i = left;
    int j = right;
    while(i!=j){
        while(a[j]<=temp&&i<j)
            j--;
        while(a[i]>=temp&&i<j)
            i++;
        if(i<j){//考虑i=j会怎么样
            int t = a[i];
            a[j]=a[i];
            a[i]t;
        }
    }
    //基准数以外的数字都找到了自己的位置，让基准数归位
    a[left]=a[i];
    a[i]=temp;
    //除了i这个位置是没有问题的，其他的两个部分自己在进行排序
    quicksort(i+1,right);
    quicksort(left,i-1);
}`

`int main(){
    scanf("%d",&n);
    for (int i =1; i <=n; i++){
        scanf("%d",&a[i]);
    }
    quick(1,n);
    for(int i=1; i <=n; i++){
        printf("%d",a[i]);
    }
    return 0;
}`

好了，接下来说一下算法复杂度的问题哈：
最差O（n^2）（和冒泡一样）
平均O（nlogn）
算法不稳定，两个相等的数字可能会跑来跑去。空间复杂度（O（log2n）~O（n）

今天好好的说一下怎么计算其平均时间复杂度：
快速排序的基本思想是通过一次排序将序列分成两段独立的序列，将一个数字放置到其应该被放置的位置，使左边的都比其小，右边的都比其大（或者相反）

最优的划分使每一次都可以将序列划分成几乎等长的两个独立序列，然后让他们独立排序,直到只有无法划分，这个是不是和二分法特别像？
那么最多需要递归次数是：
n:oringinal~
1：n次比较
2：n/2次比较*2
3：n/4次比较*4
4：n/8次比较*8
。。。
x：n/2^(x-1)次比较*2^(x-1)

所以就是有x层每层都需要比较n-1，n-2次。。。（因为每次划分中间的都不需要比较了）
所以一共就是看有多少层。2^(x-1)=n 所以logn=x-1（2为底）
每层又是n约等于n的一个常数
所以其算法复杂度为O（nlogn）（省略+1），2为底
